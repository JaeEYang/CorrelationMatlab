import numpy as np
from pathlib import Path
from magicgui.widgets import FileEdit, PushButton, ComboBox, Container, Label
import mrcfile
from skimage import io
from napari.layers import Image
from correlation2d3d import NavBuilt as nb
from correlation2d3d import SupportNav as sn
from qtpy.QtWidgets import QFileDialog
from napari.viewer import Viewer

# Global state: linked images and points
assigned_images = {"Image 1": None, "Image 2": None}
assigned_points = {"Image 1": None, "Image 2": None}


# ---------------------------
# NAV parsing + reconstruction
# ---------------------------

def points2nav_widget(viewer: "Viewer") -> Container:
    # GUI widgets
    csv_edit = FileEdit(label="Points CSV", mode="r", filter="*.csv")
    nav_edit = FileEdit(label="Template NAV", mode="r", filter="*.nav")
    combo = ComboBox(label="Assign to Map", choices=[])

    btn_view = PushButton(text="View Points")
    btn_add = PushButton(text="Add Points to NAV")

    # --- Step 1: Load CSV and preview points
    def _on_view(event=None):
        csv_path = csv_edit.value
        if not csv_path or not Path(csv_path).exists():
            print("❌ CSV file not found")
            return

        coords = np.loadtxt(str(csv_path), delimiter=",")
        if coords.ndim == 1:
            coords = coords.reshape(1, -1)

        if coords.shape[1] < 2:
            print("❌ CSV must have at least 2 columns (X,Y)")
            return

        # Preview only XY for Napari
        pts = coords[:, :2]
        viewer.add_points(
            pts,
            name="Preview Points",
            size=10,
            face_color="yellow",
        )
        print(f"✅ Displayed {pts.shape[0]} points from {csv_path}")

    # --- Step 2: Load NAV file (after CSV is already loaded)
    def _on_nav_change(event=None):
        nav_path = nav_edit.value
        if nav_path and Path(nav_path).exists():
            navdata = nb.parseNavFile(str(nav_path))
            if navdata.Maps:
                combo._maps = navdata.Maps  # store objects
                combo.choices = [
                    f"Map {m.Label} (ID={m.MapID}, Regis={m.Regis})"
                    for m in navdata.Maps
                ]
                print(f"✅ Loaded {len(navdata.Maps)} map(s) from {nav_path}")

    nav_edit.changed.connect(_on_nav_change)

    # --- Step 3: Add points into NAV
    def _on_add(event=None):
        csv_path = csv_edit.value
        nav_path = nav_edit.value

        if not csv_path or not Path(csv_path).exists():
            print("❌ CSV file not found")
            return
        if not nav_path or not Path(nav_path).exists():
            print("❌ Template NAV file not found")
            return
        if not hasattr(combo, "_maps") or combo.value is None:
            print("❌ Please select a map from the dropdown")
            return

        # Ask where to save
        out_path, _ = QFileDialog.getSaveFileName(
            None, "Save Output NAV", "output.nav", "NAV Files (*.nav)"
        )
        if not out_path:
            print("⚠ Save cancelled")
            return

        # Parse NAV and chosen map
        navdata = nb.parseNavFile(str(nav_path))

        # Find the index of the currently selected item
        if combo.value not in combo.choices:
            print("❌ No valid map selected")
            return
        
        map_index = combo.choices.index(combo.value)
        map_item = combo._maps[map_index]

        # Load CSV coords
        coords = np.loadtxt(str(csv_path), delimiter=",")
        if coords.ndim == 1:
            coords = coords.reshape(1, -1)

        new_points = []
        point_layer_data = []

        for j, row in enumerate(coords, start=1):
            if len(row) == 2:
                x, y = row
                z = 0.0
            else:
                x, y, z = row[:3]

            p = nb.PointItem()
            p.Label = str(len(navdata.Points) + j)
            p.StageXYZ = [float(x), float(y), float(z)]
            p.PtsX = float(x)
            p.PtsY = float(y)
            p.DrawnID = map_item.MapID
            p.Regis = map_item.Regis
            navdata.addPointItem(p)
            new_points.append(p)
            point_layer_data.append([x, y])

        # Write out new NAV
        with open(out_path, "w") as f:
            with open(nav_path, "r") as fin:
                f.write(fin.read()) # preserve everything

            ## Append only the new points
            for p in new_points:
                f.write("\n\n")
                f.write("\n".join(p.getText()))

        print(f"✅ NAV written: {out_path}")

        # Add final points layer
        if point_layer_data:
            viewer.add_points(
                np.array(point_layer_data),
                name=f"Points (MapID {map_item.MapID})",
                size=10,
                face_color="yellow",
            )

    # Hook up buttons
    btn_view.clicked.connect(_on_view)
    btn_add.clicked.connect(_on_add)

    return Container(widgets=[csv_edit, btn_view, nav_edit, combo, btn_add])

# ---------------------------
# Load Images Widget
# ---------------------------
def load_images_widget(viewer: "napari.viewer.Viewer") -> Container:
    mrc_edit = FileEdit(label="", mode="r", filter="*.mrc *.tif *.tiff *.png *.jpg")
    nav_edit = FileEdit(label="", mode="r", filter="*.nav")
    button = PushButton(text="Load Images")

    def _on_click(event=None):
        mrc_path = mrc_edit.value
        nav_path = nav_edit.value

        if not mrc_path or not Path(mrc_path).exists():
            print("❌ Please select an MRC or image file")
            return

        # Load MRC or normal image
        if Path(mrc_path).suffix.lower() == ".mrc":
            with mrcfile.open(str(mrc_path), permissive=True) as mrc:
                data = np.copy(mrc.data)
            viewer.add_image(data, name=Path(mrc_path).stem, colormap="gray")
        else:
            img = io.imread(str(mrc_path))
            viewer.add_image(img, name=Path(mrc_path).stem)

        # If nav present, try montage maps
        if nav_path and Path(nav_path).exists():
            maps, _ = parse_nav(nav_path)
            for mid, info in maps.items():
                mrc_file = Path(nav_path).parent / info["file"]
                if not mrc_file.exists():
                    continue
                montage = reconstruct_from_nav(mrc_file, info["coords"])
                viewer.add_image(montage, name=f"Montage Map {mid}", colormap="gray")

    button.clicked.connect(_on_click)
    return Container(widgets=[mrc_edit, nav_edit, button])


# ---------------------------
# Image Panel (Image 1 / 2)
# ---------------------------
def make_image_panel(viewer: "napari.viewer.Viewer", name: str = "Image 1") -> Container:
    combo = ComboBox(label=f"Select {name}", choices=[])
    label = Label(value=f"{name}: None")
    clear_btn = PushButton(text="Clear")
    rotate_btn = PushButton(text="Rotate 90°")
    flipv_btn = PushButton(text="Flip V")
    fliph_btn = PushButton(text="Flip H")
    new_pts_btn = PushButton(text="New Points Layer")

    def refresh_choices(event=None):
        combo.choices = [layer.name for layer in viewer.layers if isinstance(layer, Image)]

    viewer.layers.events.inserted.connect(refresh_choices)
    viewer.layers.events.removed.connect(refresh_choices)

    def on_select(event=None):
        if combo.value:
            assigned_images[name] = viewer.layers[combo.value]
            label.value = f"{name}: {combo.value}"

    def on_clear(event=None):
        assigned_images[name] = None
        assigned_points[name] = None
        label.value = f"{name}: None"

    def transform_image(fn):
        layer = assigned_images.get(name)
        if layer is None:
            return
        data = layer.data
        layer.data = fn(data)

        # Apply transformation also to linked points
        points_layer = assigned_points.get(name)
        if points_layer is not None:
            pts = points_layer.data.copy()
            if fn == np.flipud:
                pts[:, 1] = data.shape[0] - pts[:, 1]
            elif fn == np.fliplr:
                pts[:, 0] = data.shape[1] - pts[:, 0]
            elif fn.__name__ == "<lambda>":
                W = data.shape[1]
                new_pts = np.zeros_like(pts)
                new_pts[:, 0] = pts[:, 1]
                new_pts[:, 1] = W - pts[:, 0]
                pts = new_pts
            points_layer.data = pts

    def on_new_points(event=None):
        layer = viewer.add_points(
            np.empty((0, 2)),
            name=f"{name} Points",
            size=10,
            face_color="red" if name == "Image 1" else "blue"
        )
        assigned_points[name] = layer

    rotate_btn.clicked.connect(lambda e: transform_image(lambda d: np.rot90(d, k=1)))
    flipv_btn.clicked.connect(lambda e: transform_image(np.flipud))
    fliph_btn.clicked.connect(lambda e: transform_image(np.fliplr))
    new_pts_btn.clicked.connect(on_new_points)

    combo.changed.connect(on_select)
    clear_btn.clicked.connect(on_clear)

    return Container(widgets=[combo, label, clear_btn,
                              rotate_btn, flipv_btn, fliph_btn,
                              new_pts_btn])


# ---------------------------
# Load Points Widget
# ---------------------------
def load_points_widget(viewer: "napari.viewer.Viewer") -> Container:
    file_edit = FileEdit(label="", mode="r", filter="*.csv")
    combo = ComboBox(label="Assign to", choices=["Image 1", "Image 2"])
    button = PushButton(text="Load Points")

    def _on_click(event=None):
        path = file_edit.value
        if not path or not Path(path).exists():
            return

        pts = np.loadtxt(str(path), delimiter=",")
        if pts.ndim == 1:
            pts = pts.reshape(1, -1)

        if pts.shape[1] >= 2:
            layer = viewer.add_points(
                pts[:, :2],
                name=f"{combo.value} Points",
                size=10,
                face_color="red" if combo.value == "Image 1" else "blue"
            )
            assigned_points[combo.value] = layer

    button.clicked.connect(_on_click)
    return Container(widgets=[file_edit, combo, button])
